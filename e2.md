Of course. Based on the details provided, the most likely issue is a subtle interaction between the `headers` and `proxyRequestHeaders` options in `createB2BUA`, or the headers being stripped before they are sent over the wire.

Here are the answers to your questions, along with a recommended path to solve the problem.

-----

### 1\. drachtio-srf Behavior

Yes, in `drachtio-srf`, custom headers provided in the `headers` object parameter of the `createB2BUA` function **should be automatically included** in the outgoing SIP INVITE sent to the B-leg. You do not need additional configuration for this to work.

However, the behavior can be altered by other options. The `proxyRequestHeaders` option is designed to copy headers from the incoming A-leg request to the outgoing B-leg request. If you use `proxyRequestHeaders: ['all']`, it might create a new set of headers from the A-leg, potentially ignoring the new custom headers you've defined in the separate `headers` object. The most reliable method is to use *only* the `headers` object to explicitly define what you need on the B-leg, or to add the headers to the original `req` object *before* calling `createB2BUA` and then list them in `proxyRequestHeaders`.

**Recommendation:** For your test, remove the `proxyRequestHeaders` option entirely and rely solely on the `headers` object to see if your custom headers are passed.

-----

### 2\. SIP Protocol Compliance

No, there are **no SIP protocol restrictions** that would inherently cause a compliant server to filter or drop properly formatted custom headers prefixed with `X-`. The `X-` prefix is the standard convention for non-standard, experimental, or application-specific headers.

Any dropping or filtering of these headers would be due to the specific configuration or implementation logic of an intermediary SIP proxy, SBC, or B2BUA, not a violation of the SIP protocol (RFC 3261) itself. Since both your SBC and Feature Server are part of the same trusted Jambonz platform within a Docker network, it's highly improbable that a protocol-level filter is the cause.

-----

### 3\. Debugging Approach üïµÔ∏è

The best way to verify if the headers are on the wire is to perform a packet capture on the SBC-Inbound container and inspect the raw SIP messages. This will definitively tell you if the header is leaving the SBC-Inbound application or if it's being dropped at the Feature Server.

The ideal tool for this is **sngrep**, as it's designed to capture and beautifully display SIP dialogs.

Here‚Äôs the step-by-step process:

1.  **Find your container name:**

    ```bash
    docker ps
    ```

    Look for the name of your SBC-Inbound container (e.g., `jambonz-sbc-inbound-1`).

2.  **Install `sngrep` in the running container:**

    ```bash
    # Replace <container_name> with your actual container name
    docker exec -it <container_name> bash -c "apt-get update && apt-get install -y sngrep"
    ```

3.  **Run `sngrep`:**

    ```bash
    docker exec -it <container_name> sngrep
    ```

4.  **Trigger a call.** You will see the call flow appear in `sngrep`'s interface. Select the `INVITE` message going from your SBC-Inbound to the Feature Server and inspect its headers. If `X-Account-Sid` is present there, the problem is in the Feature Server's application logic. If it's missing, the problem is within the SBC-Inbound's `createB2BUA` call.

If you can't install `sngrep`, you can use `tcpdump`:

```bash
# Capture SIP traffic (port 5060) and print to console
docker exec -it <container_name> tcpdump -i any -A -n udp port 5060
```

This is less user-friendly but will show you the raw packet contents.

-----

### 4\. Alternative Solutions

If custom headers continue to be problematic, passing the account context via the **Request-URI** is a very common and robust alternative in multi-tenant SIP architectures. The Feature Server can then parse the account SID directly from the URI.

Modify the `uri` you pass to `createB2BUA` in one of two ways:

**Option A: Pass it as a user part of the URI.**
This is a clean and common pattern. The Feature Server would be configured to treat the user part of the URI as the account identifier.

```javascript
// In SBC-Inbound call-session.js
const account_sid = this.req.locals.account_sid;
const uri = `sip:${account_sid}@feature-server-ip:5060`; // or your service name

const {uas, uac} = await this.srf.createB2BUA(this.req, this.res, uri, {
    // ... your other options
    headers: { /* standard headers here */ }
});
```

On the Feature Server, you would then parse it from `req.uri.user`.

**Option B: Pass it as a URI header/parameter.**
This is also fully compliant with SIP standards.

```javascript
// In SBC-Inbound call-session.js
const account_sid = this.req.locals.account_sid;
const uri = `sip:feature-server-ip:5060;account_sid=${account_sid}`;

const {uas, uac} = await this.srf.createB2BUA(this.req, this.res, uri, {
    // ...
});
```

The Feature Server can then parse this parameter from the `req.uri` object.

-----

### 5\. Version Compatibility

While possible, a version incompatibility in something as fundamental as header manipulation is **unlikely to be the root cause** unless you are using very old or mismatched versions of `drachtio-server` and `drachtio-srf`. This issue is more commonly traced back to application logic or configuration nuances.

Before assuming a version bug, it is critical to use `sngrep` to confirm the on-the-wire behavior. If the packet capture shows the header is not being sent despite correct code, you could then investigate potential version issues by checking the release notes or open issues for `jambonz-srf` (the Jambonz fork of `drachtio-srf`) on GitHub.